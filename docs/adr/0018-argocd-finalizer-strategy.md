# ADR-0018: ArgoCD Finalizer Strategy

## Status

Accepted

## Context

ArgoCD supports the `resources-finalizer.argocd.argoproj.io` finalizer on Application and AppProject resources. When present on an Application, deleting that Application triggers a **cascade deletion**: ArgoCD first deletes all Kubernetes resources managed by the Application, then removes the finalizer, and only then does the Application object itself get garbage-collected. Without the finalizer, deleting an Application just removes the Application object from ArgoCD, leaving the actual Kubernetes resources orphaned in the cluster.

We use the app-of-apps pattern, which creates a hierarchy:

```
app-of-apps (Application)
  └── child Applications (keycloak, backstage, cert-manager, ...)
        └── Kubernetes resources (Deployments, Services, Secrets, ...)
```

The question is: at which levels should we apply the resources-finalizer?

### Historical naming

ArgoCD has used two names for the same finalizer:

- `argoproj.io/resources-finalizer` (old format)
- `resources-finalizer.argocd.argoproj.io` (current canonical format)

Both work identically. We standardize on the canonical format for consistency.

### Problem observed

Previously, we set the resources-finalizer on the app-of-apps Application itself. During uninstall, this created a deep cascade chain:

1. Delete app-of-apps
2. Finalizer blocks until all child Applications are deleted
3. Each child Application's finalizer blocks until all its Kubernetes resources are deleted
4. Each resource deletion depends on running controllers, webhooks, and functioning networking

This cascade was slow and fragile. If any part of the chain got stuck (e.g., an orphaned webhook blocking resource creation, a controller pod that couldn't start), the entire app-of-apps remained in `Terminating` state indefinitely. If the install script ran again while these resources were terminating, `kubectl apply` would update the dying objects, and ArgoCD would refuse to sync them ("Skipping auto-sync: deletion in progress"), leaving the platform in a broken state.

## Decision

### 1. No finalizer on app-of-apps

The app-of-apps Application does NOT have a resources-finalizer:

```yaml
metadata:
  name: app-of-apps-{{ cluster_name }}
  namespace: argocd
  # No resources-finalizer: deleting app-of-apps with a finalizer triggers
  # a deep cascade that is slow and fragile. kr uninstall handles cleanup
  # explicitly.
```

The app-of-apps is only ever deleted during platform uninstall. The `kr uninstall` command handles the deletion lifecycle explicitly: it deletes child applications, clears stuck finalizers, removes orphaned webhook configurations, and deletes namespaces in a controlled sequence.

If someone accidentally deletes app-of-apps without `kr uninstall`, the child Applications become "orphaned" from their parent but continue running and functioning normally. Re-creating app-of-apps (by re-running `kr deploy`) causes ArgoCD to re-adopt them.

### 2. Resources-finalizer on all child Applications

Every child Application generated by the template has the resources-finalizer:

```yaml
finalizers:
- resources-finalizer.argocd.argoproj.io
```

This is necessary for normal operations. When an application is disabled (set `enabled: false`), the app-of-apps sync prunes the child Application. The finalizer ensures that pruning also cleans up the actual Kubernetes resources (Deployments, Services, ConfigMaps, etc.) instead of orphaning them.

### 3. Resources-finalizer on AppProject

The AppProject has the resources-finalizer:

```yaml
finalizers:
  - resources-finalizer.argocd.argoproj.io
```

On an AppProject, this finalizer has different behavior than on an Application: it prevents the project from being deleted while any Application still references it. This is a lightweight safety net (no cascade deletion of resources). The uninstall script accounts for this by deleting applications before the project.

### 4. Additional finalizers for specific applications

Some applications require extra ArgoCD finalizers for proper cleanup. These are specified per-application in `app-of-apps/values-base.yaml` via the `finalizers` field:

```yaml
kyverno:
  finalizers:
    - post-delete-finalizer.argocd.argoproj.io
    - post-delete-finalizer.argocd.argoproj.io/cleanup
```

The `post-delete-finalizer` triggers ArgoCD post-delete hooks (cleanup jobs) that run after the application's resources are deleted. Kyverno needs this to clean up its cluster-scoped webhook configurations and policies.

## Consequences

- Uninstalling the platform is fast and reliable. Deleting app-of-apps is instant (no cascade), and the uninstall script handles cleanup with proper error handling and finalizer clearing.
- Disabling individual applications still cascades correctly through the child Application finalizer, ensuring no orphaned resources during normal operations.
- The AppProject cannot be accidentally deleted while applications reference it.
- Re-running install.sh after a failed or partial uninstall works cleanly because there are no stuck app-of-apps objects in Terminating state.
- The trade-off: accidentally deleting app-of-apps (without the uninstall script) orphans child Applications from their parent. This is a minor operational inconvenience (re-run install.sh to fix) rather than a data loss risk, since the actual workloads keep running.
