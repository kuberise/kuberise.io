# kuberise.io Project Rules

## Project Overview
kuberise.io is a free open source internal developer platform for Kubernetes environments. It provides tools and templates for fast and easy installation to help developers focus on business applications rather than infrastructure setup and configuration.

The platform uses GitOps principles with ArgoCD for declarative application management and follows the app-of-apps pattern for managing multi-cluster, multi-cloud, multi-environment, multi-application, multi-values architecture.

## Architecture & Design Patterns

### GitOps & App-of-Apps Pattern
- Uses ArgoCD for GitOps-based application deployment
- App-of-apps pattern: `app-of-apps/` contains the root ArgoCD Application that manages all other applications
- All applications are defined as ArgoCD Applications in `app-of-apps/templates/ArgocdApplications.yaml`
- Applications are enabled/disabled via values files

### Multi-Source ArgoCD Applications
- Helm-type applications use `spec.sources` (plural) with two sources:
  1. **Chart source**: Direct reference to external Helm chart repository (via `chart` + `repoURL` + `targetRevision`) or path to a local chart
  2. **Values source**: A `ref: values` source pointing to the Git repository containing value files
- Value files use `$values/` prefix to reference files from the values repository
- Non-Helm applications (kustomize, raw) continue to use single-source `spec.source`
- See ADR-0014 for the rationale behind this architecture

### External Chart References
- External Helm charts are referenced directly in `app-of-apps/values.yaml` using `chart`, `repoURL`, and `targetRevision` fields
- No wrapper charts or local Chart.yaml dependencies for external charts
- Values are passed directly to the upstream chart (no subchart nesting)
- The `scripts/upgrade.sh` script reads chart references from `values.yaml` to check for updates

### Operator + Config Chart Pattern
- Components that install an operator AND need custom configuration resources are split into two ArgoCD Applications:
  - **Operator app**: References the upstream chart directly (e.g., `cert-manager`)
  - **Config app**: A small local chart with CRD instances and configuration (e.g., `cert-manager-config`)
- Config charts use `syncWave: 2` to ensure the operator and CRDs are installed first
- Examples: `cert-manager` + `cert-manager-config`, `keycloak` + `keycloak-config`, `kyverno` + `policy`, `postgres-operator` + `database`

### Multi-Cluster Support
The project supports multiple Kubernetes clusters. These clusters can represent:
- Different environments (e.g., dev, test, prod clusters)
- Multiple regional clusters for the same environment (e.g., multiple regional production clusters: prod-us-east, prod-us-west, prod-eu)
- Multi-cloud or hybrid architectures

All clusters share the same charts in the `charts/` folder and the same external chart references in `values.yaml`.

Each cluster has its own values directory:
- `values/{cluster}/platform/` for the configuration of the platform components
- `values/{cluster}/applications/` for the configuration of the developer applications

### Value File Hierarchy
Values files follow a specific hierarchy for overrides:
1. Default values: `values/defaults/platform/{component}/values.yaml`
2. Cluster-specific overrides: `values/{cluster}/platform/{component}/values.yaml`

ArgoCD Applications automatically merge these files in order (defaults first, then cluster-specific).

## Directory Structure

### Key Directories
- `app-of-apps/`: Root Helm chart for ArgoCD app-of-apps pattern
  - `values.yaml`: Main configuration with all ArgoCD Applications definitions (including external chart references)
  - `values-{cluster}.yaml`: Cluster-specific overrides
  - `templates/ArgocdApplications.yaml`: Template that generates ArgoCD Application manifests

- `charts/`: Local Helm charts and kustomize applications (only for components not available from external repositories)
  - Local charts: `backstage`, `generic-deployment`, `ingresses`, `kube-prometheus-stack-crds`, `secrets-manager`, `team-setup`, `teams-namespaces`, `tekton-operator`
  - Config charts: `cert-manager-config`, `keycloak-config`, `metallb-config`, `pgadmin-config`, `k8sgpt-config`
  - Kustomize apps: `dashboards`, `hello`

- `values/`: Configuration values organized by cluster
  - `values/{cluster}/platform/`: Platform component configurations
  - `values/{cluster}/applications/`: Application-specific configurations

- `scripts/`: Installation and utility scripts
  - `install.sh`: Main installation script that sets up the platform
  - `uninstall.sh`: Uninstallation script
  - `upgrade.sh`: Upgrade script that checks for newer versions of external charts referenced in `values.yaml`
  - `k3d+registry/`: Scripts for local multi-cluster development setup
    - Creates two k3d clusters (shared and dev) connected via Cilium ClusterMesh
    - Sets up Docker registry proxy for local image caching
    - See "Local Development with k3d Clusters" section for details
  - `more/`: Additional utility scripts

- `docs/adr/`: Architecture Decision Records (ADR)
  - ADRs are stored in `docs/adr/` as numbered markdown files (e.g., `0001-sync-policy-configuration.md`)
  - Use the standard ADR format: Status, Context, Decision, Consequences
  - Document rejected alternatives within the relevant accepted ADR under the Decision section
  - When a decision is replaced, create a new ADR and update the old one's status to "Superseded by ADR-XXXX"

### Application Types
ArgoCD Applications support three types:
1. `helm`: Default type, uses Helm charts (most common)
2. `kustomize`: Uses Kustomize for manifest management
3. `raw`: Direct Kubernetes manifests without templating

## Coding Conventions

### YAML Formatting
- Use 2-space indentation
- Follow Kubernetes YAML best practices
- Use meaningful comments to explain complex configurations
- Group related configurations together

### Helm Chart Structure
- Follow Helm 3 best practices
- Use `_helpers.tpl` for reusable template functions
- Chart names should match directory names (kebab-case)
- Include `Chart.yaml` with proper versioning

### Naming Conventions
- Component names: kebab-case (e.g., `cert-manager`, `external-dns`)
- Namespace names: Usually match component name or follow Kubernetes conventions
- Resource names: Use Helm template functions like `{{ include "component.fullname" . }}`
- Cluster names: kebab-case following this pattern: [environment]-[type(shared/app)]-[provider]-[region]. Examples:
  - prod-app-aws-frankfort
  - acc-app-aws-frankfort
  - prod-shared-gcp-groningen
  - dev-shared-onprem-one
  - dev-app-onprem-one
  - dev-app-onprem-two


### Value File Patterns
- Always provide sensible defaults in `values/defaults/`
- Default value files (`values/defaults/platform/{component}/values.yaml`) must always exist, even if empty, to serve as placeholders showing the available components
- Cluster-specific value files (`values/{cluster}/platform/{component}/values.yaml`) should only be created when there are actual overrides needed; do NOT create empty placeholder files in cluster directories
- The ArgoCD template uses `ignoreMissingValueFiles: true`, so missing cluster-specific value files are silently skipped and only defaults are applied
- See ADR-0002 for the rationale behind this convention
- Values are passed directly to upstream charts (no subchart nesting prefix)
- Use `global.domain` for domain configuration (injected by install script)
- Use `global.cluster` for cluster-specific references

### ArgoCD Application Configuration
- Applications are defined in `app-of-apps/values.yaml` under `ArgocdApplications`
- Each application has:
  - `enabled`: Boolean to enable/disable
  - `namespace`: Target namespace (defaults to component name)
  - `path`: Path to local Helm chart or manifests (defaults to `charts/{name}`)
  - `chart`: Helm chart name for external chart repositories
  - `repoURL`: External Helm chart repository URL
  - `targetRevision`: External Helm chart version
  - `type`: Application type (helm/kustomize/raw)
  - `values`: Optional list of custom value file paths (use `$values/` prefix) to override the default value file convention
  - `valuesFolder`: Optional folder name to use instead of `platform` in the default value file paths
  - `valuesRepoURL`: Optional override for the values repository URL (split-repo topology)
  - `valuesTargetRevision`: Optional override for the values repository revision
  - `syncWave`: Optional sync wave for ordering
  - `serverSideApply`: Optional boolean to control ServerSideApply (defaults to true)
  - `syncOptions`: Optional additional sync options (additive, does not replace defaults)
  - `finalizers`: Optional additional finalizers
  - `team`: Optional team name label (defaults to `platform`)

### Domain Configuration
- All services use subdomains of `global.domain`
- Pattern: `{service-name}.{global.domain}`
- Example: `keycloak.minikube.kuberise.dev`

## Platform Components

### Core Platform Services
- **ArgoCD**: GitOps continuous delivery tool
- **ArgoCD Image Updater**: Automated image updates
- **Backstage**: Developer portal
- **Gitea**: Git repository hosting
- **Rancher**: Kubernetes management platform
- **vcluster**: Virtual Kubernetes clusters

### Data Services
- **PostgreSQL Operator (CloudNativePG)**: Managed PostgreSQL databases
- **pgAdmin**: PostgreSQL administration tool
- **Redis**: In-memory data store
- **MinIO**: Object storage

### Network Services
- **MetalLB**: Load balancer for bare metal/on-prem
- **External DNS**: DNS record management
- **Ingress NGINX**: Ingress controller (internal/external)
- **Cilium**: CNI and network policy enforcement

### Security & Authentication
- **Keycloak**: Identity and access management
- **Keycloak Operator**: Keycloak lifecycle management
- **OAuth2 Proxy**: Authentication proxy
- **External Secrets Operator**: Secret management
- **Sealed Secrets**: Encrypted secrets
- **Vault**: Secrets management
- **Vault Secrets Operator**: Vault integration
- **Cert Manager**: Certificate management
- **Kyverno**: Policy engine
- **NeuVector**: Container security

### Monitoring & Observability
- **Prometheus Stack**: Metrics collection and alerting
- **Loki**: Log aggregation
- **Promtail**: Log shipper
- **OpenCost**: Cost monitoring
- **Metrics Server**: Kubernetes metrics API
- **Dashboards**: Grafana dashboards (kustomize-based)

### AI & Developer Tools
- **Ollama**: LLM inference server
- **k8sgpt**: Kubernetes AI assistant

### CI/CD
- **Tekton Operator**: Kubernetes-native CI/CD pipelines

### Example Applications
- `generic-deployment`: Reusable Helm chart for deploying applications
- Example apps: `show-env`, `frontend-https`, `backend`, `api`, `grpc-server`

## Installation Process

### Prerequisites
- CLI tools: `kubectl`, `helm`, `htpasswd`, `git`, `openssl`
- GitHub account or git repository
- Kubernetes cluster (kind, minikube, or cloud provider)
- K9s recommended for dashboard

### Installation Script
The `scripts/install.sh` script:
1. Validates required tools
2. Creates necessary namespaces and secrets
3. Generates CA certificates if needed
4. Installs ArgoCD
5. Creates the root ArgoCD Application (app-of-apps)
6. Configures Git repository access

### Installation Parameters
```bash
./scripts/install.sh [CONTEXT] [NAME] [REPO_URL] [REVISION] [DOMAIN] [TOKEN]
```
- `CONTEXT`: Kubernetes context name
- `NAME`: Cluster name (must match values directory, e.g., `aks`, `eks`, `gke`, `onprem`, `airgap`)
- `REPO_URL`: Git repository URL
- `REVISION`: Branch/tag/commit SHA
- `DOMAIN`: Base domain for services
- `TOKEN`: Optional Git token for private repos

### Local Development with k3d Clusters

The `scripts/k3d+registry/` directory contains scripts for setting up a local multi-cluster development environment using k3d.

#### Purpose
These scripts create two local k3d clusters connected via Cilium ClusterMesh:
- **shared cluster**: Hosts platform shared tools and observability components (Prometheus, Loki, Grafana, etc.)
- **dev cluster**: Hosts developer applications

The clusters are connected via Cilium ClusterMesh, enabling developer applications in the dev cluster to send logs and metrics to observability platform components in the shared cluster.

#### Scripts Overview

- **`start.sh`**: Main script that:
  1. Starts a Docker registry proxy for caching container images
  2. Creates two k3d clusters (`shared` and `dev`) on the same network (`kuberise`)
  3. Configures both clusters to use the registry proxy for faster image pulls
  4. Sets up persistent image storage to preserve pulled images across cluster recreations

- **`docker-registry-proxy.sh`**: Creates a local Docker registry proxy container that:
  - Caches images from major registries (registry.k8s.io, gcr.io, quay.io, ghcr.io, public.ecr.aws)
  - Reduces bandwidth usage and speeds up image pulls
  - Runs on the `kuberise` network for cluster access

- **`shared.yaml`**: k3d configuration for the shared cluster
  - Disables Traefik, ServiceLB, and NetworkPolicy (to allow Cilium installation)
  - Configures registry proxy environment variables
  - Sets up persistent image storage

- **`dev.yaml`**: k3d configuration for the dev cluster
  - Same configuration as shared cluster
  - Both clusters share the same network for ClusterMesh connectivity

- **`delete-all.sh`**: Utility script to delete both clusters

#### Usage
```bash
# Create both clusters
./scripts/k3d+registry/start.sh

# After clusters are created, install Cilium CNI and ClusterMesh
# Then run install.sh for each cluster:
./scripts/install.sh k3d-shared shared <REPO_URL> <REVISION> <DOMAIN>
./scripts/install.sh k3d-dev dev <REPO_URL> <REVISION> <DOMAIN>

# Delete both clusters
./scripts/k3d+registry/delete-all.sh
```

#### Architecture Notes
- Both clusters are on the same Docker network (`kuberise`) enabling direct communication
- Cilium is installed as the CNI in both clusters
- Cilium ClusterMesh connects the clusters, allowing cross-cluster service discovery and networking
- The registry proxy provides local caching and reduces external registry dependencies

## Development Guidelines

### Adding a New External Component
1. Add application definition to `app-of-apps/values.yaml` under `ArgocdApplications` with `chart`, `repoURL`, and `targetRevision` fields
2. Set `enabled: false` by default
3. Add default values in `values/defaults/platform/{component-name}/values.yaml` even if it is empty (placeholder files in defaults are required). Values should be at the top level (no subchart nesting).
4. Only create cluster-specific values in `values/{cluster}/platform/{component-name}/values.yaml` if there are actual overrides for that cluster. Do NOT create empty placeholder files in cluster directories (see ADR-0002).
5. Add application definition to `app-of-apps/values-{cluster}.yaml` under `ArgocdApplications`
6. Set `enabled: true` if the component is going to be installed in that cluster.
7. If the component needs custom CRD instances or configuration resources, create a separate config chart in `charts/{component-name}-config/` and a corresponding config app entry (see Operator + Config Chart Pattern).
8. Document component in the documentation.
9. **Website update**: Update the kuberise.io website (https.kuberise.io repo): add the tool's name and logo to the homepage.

### Adding a New Local Chart
1. Create Helm chart in `charts/{component-name}/`
2. Add default values in `values/defaults/platform/{component-name}/values.yaml` even if it is empty
3. Add application definition to `app-of-apps/values.yaml` (no `chart`/`repoURL`/`targetRevision` needed; defaults to `charts/{name}` path)
4. Follow the same cluster enable/disable pattern as external components

### Adding a New Field to ArgoCD Application Template
When adding a new property to `app-of-apps/templates/ArgocdApplications.yaml`, you must also add the property to `app-of-apps/values.schema.json` under `definitions.argocdApplication.properties`. Failing to do so will cause a schema validation error when the new field is used (see ADR-0009).

### Modifying Existing Components
1. Update values in `values/defaults/platform/{component}/values.yaml` (for external charts) or chart templates in `charts/{component}/` (for local charts)
2. Check cluster-specific overrides in `values/{cluster}/platform/{component}/values.yaml`
3. Test with at least one cluster before committing

### Script Development
- Use `set -euo pipefail` in bash scripts
- Include error handling and validation
- Add comments explaining complex logic

### Testing
- Test installations on different clusters when possible
- Verify ArgoCD sync status after changes
- Check that values merge correctly (defaults + cluster-specific)

## Common Patterns

### Helm Value Injection
- Use `global.domain` for domain configuration
- Use `global.cluster` for cluster-specific settings
- Values are injected via ArgoCD Application's `helm.parameters`

### Sync Waves
- Use `syncWave` annotation to control application deployment order
- Lower numbers deploy first
- Example: `syncWave: 1` for operators, `syncWave: 2` for config charts that depend on operator CRDs

### Namespace Management
- Most components deploy to their own namespace
- Namespace is usually the component name
- Namespaces are created automatically via `CreateNamespace=true` sync option

### Resource Naming
- Use Helm template helpers for consistent naming
- Pattern: `{{ include "component.fullname" . }}`
- Include component name in all resources

## Important Notes

- Always test changes in a development cluster first
- Keep values files organized and well-commented
- Follow semantic versioning for chart versions
- Document breaking changes in RELEASE_NOTES.md
- Maintain backward compatibility when possible
- Use ArgoCD sync policies appropriately (automated vs manual)

### Explicit default values

Being explicit about defaults improves readability -- anyone reading the template immediately sees the full set of parameters decisions without needing to know defaults from memory. It makes the intent clear. This is a common and well-regarded practice, especially in infrastructure-as-code where the consequences of misconfiguration can be significant. Explicit is better than implicit.

## References
- Project README: `README.md`
- Release Notes: `RELEASE_NOTES.md`
- Documentation: <https://kuberise.io>
